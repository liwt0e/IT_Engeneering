# Тема 9. Концепции и принципы ООП
Отчёт по теме выполнила:
  - Попов Алексей Владимирович
  - ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + | 
| Задание 3 | + | + | 
| Задание 4 | + | + |
| Задание 5 | + | + | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторные задания:

### №1. 
Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
### Ответ: 
```python
class Name:
    __slots__ = ["name"]
    def __init__(self, name):
        if name == "Лёша":
            self.name = f"Да, я {name}"
        else:
            self.name = f"Нет, я не {name}, я Лёша"

person1 = Name("Лёша")
person2 = Name("Ксюша")
print(person1.name)
print(person2.name)
```
![Меню](https://github.com/KseniaSokolenko/PI/blob/theme_9/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/1.png)

### Вывод: 
В этом коде создается класс Name с использованием механизма __slots__, который ограничивает доступные атрибуты класса одним полем name. В конструкторе класса происходит проверка имени: если оно равно "Лёша", то атрибуту name присваивается строка "Да, я Лёша"; иначе — "Нет, я не {имя}, я Лёша".
При создании объектов person1 и person2 и их последующей печати мы увидим разные результаты в зависимости от переданного имени.

### №2. 
Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
### Ответ: 
```python
class IceCream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f'Мороженое с {self.ingredient}')
        else:
            print('Обычное мороженое')


icecream = IceCream("фисташкой")
icecream.composition()
icecream = IceCream()
icecream.composition()
icecream = IceCream()
icecream.composition()
```
![Меню](https://github.com/KseniaSokolenko/PI/blob/theme_9/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/2.png)

### Вывод: 
Класс IceCream представляет собой модель мороженого, которая может содержать ингредиент или быть обычной. Метод composition() выводит информацию о составе мороженого. В примере создаются три экземпляра класса: одно мороженое с фисташками и два обычных.

### №3. 
Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
### Ответ: 
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")


obj = MyClass(123)
print(obj.get_value())
obj.set_value(14)
print(obj.get_value())
obj.set_value(241)
print(obj.get_value())
obj.del_value()
print(obj.get_value())  # тут ошибка, потому что вызывается метод, обращающийся к удаленному атрибуту (_value)
```
![Меню](https://github.com/KseniaSokolenko/PI/blob/theme_9/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/3.png)

### Вывод: 
В этом коде создается класс MyClass, который имеет приватный атрибут _value для хранения значения. Методы get_value(), set_value() и del_value() используются для получения, установки и удаления этого атрибута соответственно. Эти методы связаны со свойством value через декоратор property. В конце кода создаются экземпляры класса и выполняются различные операции с ними. Последняя строка вызывает ошибку, так как после вызова метода del_value(), атрибут _value удаляется, и попытка получить значение приводит к исключению.

### №4. 
Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
### Ответ: 
```python
class Mammal:
    className = "Mammal"

class Dog(Mammal):
    species = "canine"
    sounds = "wow"
    meeting = "wags his tail"

class Cat(Mammal):
    species = "feline"
    sounds = "meow"
    meeting = "rubs against your legs"

dog = Dog()
print(f"Dog is {dog.className}, but it says {dog.sounds}. During a meeting, it {dog.meeting}.")
cat = Cat()
print(f"Cat is {cat.className}, but it says {cat.sounds}. During a meeting, it {cat.meeting}.")
```
![Меню](https://github.com/KseniaSokolenko/PI/blob/theme_9/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/4.png)

### Вывод: 
В этом коде демонстрируется использование наследования в Python. Класс Mammal является базовым классом для классов Dog и Cat. Оба подкласса наследуют атрибут className, а также определяют свои собственные атрибуты (species, sounds, meeting), характеризующие поведение собак и кошек соответственно. В конце кода создаются экземпляры классов Dog и Cat, после чего их характеристики выводятся на экран.

### №5. 
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.
### Ответ: 
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")


class English:
    @staticmethod
    def greeting():
        print("Hello")


def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
![Меню](https://github.com/KseniaSokolenko/PI/blob/theme_9/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/5.png)

### Вывод: 
В данном коде реализованы два класса Russian и English, каждый из которых содержит статический метод greeting(). Метод greet() принимает объект одного из этих классов и вызывает у него метод greeting(), который выводит соответствующее приветствие на нужном языке. Таким образом, программа демонстрирует полиморфизм через использование одинаковых методов в разных классах для выполнения схожих задач.
